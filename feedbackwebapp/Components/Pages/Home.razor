@page "/"
@* Updated to handle single URLs instead of comma-separated lists *@
@namespace FeedbackWebApp.Components.Pages

@using System.Web
@using Microsoft.AspNetCore.Components
@using Microsoft.JSInterop
@using FeedbackWebApp.Components.Feedback.Forms
@using FeedbackWebApp.Components.Feedback.Results
@using FeedbackWebApp.Services.Interfaces
@using FeedbackWebApp.Services.Feedback
@using FeedbackWebApp.Services.Authentication
@using FeedbackWebApp.Services
@using FeedbackWebApp.Components.Shared
@using SharedDump.Models
@using SharedDump.Models.Account
@using SharedDump.Models.BlueSkyFeedback
@using SharedDump.Models.DevBlogs
@using SharedDump.Models.GitHub
@using SharedDump.Models.HackerNews
@using SharedDump.Models.Reddit
@using SharedDump.Models.TwitterFeedback
@using SharedDump.Models.YouTube
@using SharedDump.Utils

@inject IConfiguration Configuration
@inject FeedbackServiceProvider ServiceProvider
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager
@inject UserSettingsService UserSettings
@inject IHistoryService HistoryService
@inject IAuthenticationService AuthService
@inject IRegistrationErrorService RegistrationErrorService
@inject ITwitterAccessService TwitterAccessService
@implements IDisposable

<PageTitle>Feedback Analysis - FeedbackFlow</PageTitle>

<NewFeaturesDialog 
    IsVisible="@showNewFeaturesDialog" 
    OnClose="@CloseNewFeaturesDialog"
    OnGotIt="@MarkNewFeaturesAsSeen" 
    OnRemindLater="@CloseNewFeaturesDialog" />

<UsageLimitDialog 
    UsageError="@usageLimitError" 
    IsVisible="@showUsageLimitDialog" 
    OnClose="@CloseUsageLimitDialog" />

<RegistrationErrorDialog 
    IsVisible="@showRegistrationError" 
    ErrorMessage="@registrationErrorMessage" 
    OnClose="@CloseRegistrationErrorDialog" />

<div class="container">
    @if (!isAuthenticated)
    {
        <AuthenticationForm OnAuthenticatedWithDetails="HandleAuthenticatedWithDetails" />
    }
    else
    {        
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h1 class="feedbackflow-title mb-0">Analyze</h1>
            <SourceSelector @bind-SelectedSource="selectedSource" IsDisabled="@isLoading" />
        </div>

        @if (selectedSource == "Auto")
        {
            <PlatformPills />
        }

        @if (!string.IsNullOrEmpty(selectedSource))
        {            
            <div class="card shadow-sm">
                <div class="card-body">
                    @if (selectedSource.Equals("Auto", StringComparison.OrdinalIgnoreCase))
                    {
                        <AutoDataSourceForm @ref="autoDataSourceForm" IsDisabled="@isLoading" />
                    }
                    else if (selectedSource.Equals("Manual", StringComparison.OrdinalIgnoreCase))
                    {
                        <ManualFeedbackInput @ref="manualInputForm" IsDisabled="@isLoading" />
                    }

                    <SubmitButton ShowWhenSource="@selectedSource" IsLoading="@isLoading" OnSubmit="SubmitFeedbackRequest" />
                    
                    @if (isLoading)
                    {
                        <div class="alert alert-info mt-3">
                            <div class="d-flex align-items-center">
                                <div class="spinner-border spinner-border-sm me-2" role="status"></div>
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            <div>
                                <strong>@currentStatus</strong>
                                <div class="small">@currentStatusMessage</div>
                            </div>
                        </div>
                    }                    
                        
                    <AnalysisResults 
                        Error="@error" 
                        MarkdownResult="@markdownResult" 
                        SourceType="@selectedSourceFinal"
                        UserInput="@GetUserInputForSource()"
                        AdditionalData="@GetAdditionalDataForAnalysis()" /> 

                    @* Display additional data from FeedbackSourceData list *@
                    @if (feedbackSources != null && feedbackSources.Any())
                    {
                        foreach (var source in feedbackSources)
                        {
                            if (source.AdditionalData != null)
                            {
                                @if (source.AdditionalData is List<YouTubeOutputVideo> videos)
                                {
                                    <YouTubeComments Videos="@videos" />
                                }
                                else if (source.AdditionalData is List<HackerNewsAnalysis> analyses)
                                {
                                    <HackerNewsResults Analyses="@analyses" />
                                }
                                else if (source.AdditionalData is List<GithubIssueModel> issues)
                                {
                                    <GitHubFeedback Issues="@issues" PullRequests="@null" Discussions="@null" />
                                }
                                else if (source.AdditionalData is List<GithubDiscussionModel> discussions)
                                {
                                    <GitHubFeedback Issues="@null" PullRequests="@null" Discussions="@discussions" />
                                }
                                else if (source.AdditionalData is RedditThreadModel redditThread)
                                {
                                    var redditThreads = new List<RedditThreadModel> { redditThread };
                                    <RedditComments Threads="@redditThreads" />
                                }
                                else if (source.AdditionalData is TwitterFeedbackResponse twitterResponse)
                                {
                                    <TwitterFeedbackResults Response="@twitterResponse" />
                                }
                                else if (source.AdditionalData is DevBlogsArticleModel article)
                                {
                                    <DevBlogsFeedbackResults Article="@article" />
                                }
                                else if(source.AdditionalData is BlueSkyFeedbackResponse blueSkyFeedbackResponse)
                                {
                                    <BlueSkyFeedbackResults Response="@blueSkyFeedbackResponse" />
                                }
                            }
                        }
                    }
                </div>
            </div>
        }
    }
</div>

@code {
    private AutoDataSourceForm? autoDataSourceForm;
    private ManualFeedbackInput? manualInputForm;
    private string selectedSource = "Auto";
    private string markdownResult = "";
    private string error = "";
    private bool isLoading = false;
    private bool isAuthenticated = false;
    private bool showNewFeaturesDialog = false;
    private bool showUsageLimitDialog = false;
    private bool showRegistrationError = false;
    private string? registrationErrorMessage = null;
    private UsageValidationResult? usageLimitError;
    private List<FeedbackSourceData>? feedbackSources;
    private object? currentAdditionalData;
    private FeedbackProcessStatus currentStatus;
    private string currentStatusMessage = "";
    private string? initialSource;
    private string? initialId;

    private async Task HandleAuthenticatedWithDetails((bool success, bool justLoggedIn) details)
    {
        isAuthenticated = details.success;
        StateHasChanged();

        if (details.success)
        {
            // Only handle post-login registration if the user just logged in
            // This avoids unnecessary backend calls when user was already authenticated
            if (details.justLoggedIn)
            {
                try
                {
                    await AuthService.HandlePostLoginRegistrationAsync();
                }
                catch (Exception ex)
                {
                    // Log but don't fail the authentication flow if registration has issues
                    Console.WriteLine($"Post-login registration warning: {ex.Message}");
                }
            }

            await HandleQueryNav();
            //await CheckForNewFeatures();
        }
    }

    private async Task HandleAuthenticated(bool success)
    {
        isAuthenticated = success;
        StateHasChanged();

        if (success)
        {
            // Handle post-login registration for OAuth providers (GitHub, Google, etc.)
            // This ensures users are properly registered in the backend after OAuth login
            // With caching enabled, this won't make excessive API calls
            try
            {
                await AuthService.HandlePostLoginRegistrationAsync();
            }
            catch (Exception ex)
            {
                // Log but don't fail the authentication flow if registration has issues
                Console.WriteLine($"Post-login registration warning: {ex.Message}");
            }

            await HandleQueryNav();
            //await CheckForNewFeatures();
        }
    }

    private async Task CheckForNewFeatures()
    {

        try
        {
            // Check if user has history (indicating they've used the app before)
            var hasHistory = (await HistoryService.GetHistoryCountAsync()) > 0;
            
            // Only show new features dialog if user has history and hasn't seen latest features
            if (hasHistory && await UserSettings.ShouldShowFeatureAnnouncementAsync())
            {
                // Add a small delay to let the page fully render
                await Task.Delay(1000);
                showNewFeaturesDialog = true;
                StateHasChanged();
            }
            else 
            {
                // if they are a new user or have seen the announcement, mark it as shown
                await UserSettings.MarkFeatureAnnouncementShownAsync();
            }
        }
        catch (Exception)
        {
            // If anything fails, silently continue without showing the dialog
        }
    }

    private void CloseNewFeaturesDialog()
    {
        showNewFeaturesDialog = false;
        StateHasChanged();
    }

    private async Task MarkNewFeaturesAsSeen()
    {
        await UserSettings.MarkFeatureAnnouncementShownAsync();
        CloseNewFeaturesDialog();
    }

    private void CloseUsageLimitDialog()
    {
        showUsageLimitDialog = false;
        usageLimitError = null;
        StateHasChanged();
    }

    private void HandleStatusUpdate(FeedbackProcessStatus status, string message)
    {
        currentStatus = status;
        currentStatusMessage = message;
        StateHasChanged();
    }

    private string? GetUserInputForSource()
    {
        return selectedSource switch
        {
            "Manual" => manualInputForm?.ContentInput,
            "Auto" => autoDataSourceForm?.GetUrls() is { } urls && urls.Any() ? string.Join(", ", urls) : null,
            _ => null
        };
    }

    private object? GetAdditionalDataForAnalysis()
    {
        // For Auto source type, extract additional data from feedbackSources
        if (selectedSource == "Auto" && feedbackSources != null)
        {
            // Combine all additional data from all sources
            var allAdditionalData = feedbackSources
                .Where(source => source.AdditionalData != null)
                .Select(source => source.AdditionalData)
                .ToList();

            // If there's only one type of data, return it directly
            if (allAdditionalData.Count == 1)
            {
                return allAdditionalData[0];
            }
            
            // If there are multiple types, return them as a list
            if (allAdditionalData.Count > 1)
            {
                return allAdditionalData;
            }
        }

        // For other source types, return the raw additional data
        return currentAdditionalData;
    }

    private string selectedSourceFinal => selectedSource.Equals("Auto", StringComparison.OrdinalIgnoreCase)
        ? GetSourcesFromUrls()
        : selectedSource;

    private string GetSourcesFromUrls()
    {
        if (autoDataSourceForm?.GetUrls() is not { } urls || !urls.Any())
            return "Auto";
            
        var sources = new List<string>();
        
        foreach (var url in urls)
        {
            if (string.IsNullOrWhiteSpace(url))
                continue;
                
            if (UrlParsing.IsYouTubeUrl(url))
                sources.Add("YouTube");
            else if (url.Contains("reddit.com"))
                sources.Add("Reddit");
            else if (url.Contains("news.ycombinator.com") || url.Contains("hackernews"))
                sources.Add("HackerNews");
            else if (url.Contains("github.com"))
                sources.Add("GitHub");
            else if (url.Contains("devblogs.microsoft.com"))
                sources.Add("DevBlogs");
            else if (url.Contains("bsky.app"))
                sources.Add("BlueSky");
            else
                sources.Add("Web");
        }
        
        // Return unique sources as comma-separated list, or "Auto" if no sources identified
        return sources.Distinct().Any() ? string.Join(", ", sources.Distinct()) : "Auto";
    }


    private async Task SubmitFeedbackRequest()
    {
        try
        {
            // Reset all previous data
            error = "";
            markdownResult = "";
            feedbackSources = null;
            currentAdditionalData = null;
            isLoading = true;
            currentStatus = FeedbackProcessStatus.GatheringComments;
            currentStatusMessage = "Starting analysis...";

            // For Auto source, check Twitter access before submitting
            if (selectedSource == "Auto")
            {
                var urls = autoDataSourceForm?.GetUrls() ?? new List<string>();
                var (hasAccess, accessError) = await TwitterAccessService.CheckTwitterAccessAsync(urls);
                
                if (!hasAccess && !string.IsNullOrEmpty(accessError))
                {
                    error = accessError;
                    return;
                }
            }

            IFeedbackService service = selectedSource switch
            {
                "Auto" or "auto" => ServiceProvider.CreateAutoDataSourceService(
                    autoDataSourceForm?.GetUrls().ToArray() ?? Array.Empty<string>(),
                    HandleStatusUpdate),
                "Manual" or "manual" => ServiceProvider.CreateManualService(
                    manualInputForm?.GetContent() ?? string.Empty,
                    manualInputForm?.GetSystemPrompt(),
                    HandleStatusUpdate),
                _ => throw new InvalidOperationException("Please select a feedback source")
            };

            var (result, additionalData) = await service.GetFeedback();
            markdownResult = result;
            currentAdditionalData = additionalData;

            // Handle feedbackSources for Auto source type
            if (selectedSource == "Auto" && additionalData is List<FeedbackSourceData> sources)
            {
                feedbackSources = sources;
            }
        }
        catch (UsageLimitExceededException ex)
        {
            usageLimitError = ex.LimitError;
            showUsageLimitDialog = true;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            // Check if this is a usage limit error from error message
            if (UsageLimitErrorHelper.TryParseUsageLimitError(ex.Message, out var limitError))
            {
                usageLimitError = limitError;
                showUsageLimitDialog = true;
            }
            else
            {
                error = $"An error occurred: {ex.Message}";
            }
            StateHasChanged();
        }
        finally
        {
            await Task.Delay(500); // Give time for UI to update before finalizing
            isLoading = false;
            currentStatus = FeedbackProcessStatus.Completed;
            currentStatusMessage = "";
            StateHasChanged();
        }
    }

    protected override async Task OnInitializedAsync()
    {
        // Subscribe to registration error events
        RegistrationErrorService.RegistrationErrorOccurred += OnRegistrationErrorOccurred;
        
        var uri = new Uri(NavigationManager.Uri);
        var query = System.Web.HttpUtility.ParseQueryString(uri.Query);

        // Check if this is an OAuth redirect (user just completed login)
        var isOAuthRedirect = !string.IsNullOrEmpty(query["code"]) || 
                             !string.IsNullOrEmpty(query["state"]) ||
                             uri.AbsolutePath.Contains("/.auth/login/");

        // Store auth status for later processing in OnAfterRenderAsync
        var authStatus = query["auth"];
        if (authStatus == "failed" || authStatus == "error")
        {
            // Store the auth error status to handle in OnAfterRenderAsync
            await Task.CompletedTask; // Placeholder - will handle in OnAfterRenderAsync
        }

        initialSource = query["source"]?.ToLower();
        initialId = query["id"];
        var url = query["url"];
        
        // If URL is provided, switch to Auto mode and use the URL
        if (!string.IsNullOrEmpty(url))
        {
            initialSource = "auto";
            initialId = url;
        }

        // If this is an OAuth redirect, check authentication and handle post-login registration
        if (isOAuthRedirect)
        {
            try
            {
                // Give time for OAuth tokens to settle
                await Task.Delay(500);
                
                var isAuthenticated = await AuthService.IsAuthenticatedAsync();
                if (isAuthenticated)
                {
                    // This is a fresh OAuth login, handle post-login registration
                    await HandleAuthenticatedWithDetails((true, true));
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"OAuth redirect handling error: {ex.Message}");
            }
        }

        await base.OnInitializedAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Handle authentication error logging after render
            var uri = new Uri(NavigationManager.Uri);
            var query = System.Web.HttpUtility.ParseQueryString(uri.Query);
            var authStatus = query["auth"];
            
            if (authStatus == "failed")
            {
                // Show authentication failed message
                await JSRuntime.InvokeVoidAsync("console.log", "Authentication failed");
            }
            else if (authStatus == "error")
            {
                // Show authentication error message
                await JSRuntime.InvokeVoidAsync("console.log", "Authentication error occurred");
            }
        }
    }    
    
    private async Task HandleQueryNav()
    {
        if (string.IsNullOrEmpty(initialSource) || string.IsNullOrEmpty(initialId))
            return;

        selectedSource = initialSource.ToLower() switch
        {
            "auto" or "hackernews" or "reddit" or "youtube" => "Auto",
            _ => selectedSource
        };
        StateHasChanged();        
        if (selectedSource == "Auto")
        {
            // Wait for autoDataSourceForm to be initialized, up to 10 attempts
            var attempts = 0;
            while (autoDataSourceForm is null && attempts < 10)
            {
                await Task.Delay(250);
                attempts++;
            }

            if (autoDataSourceForm is not null)
            {
                await autoDataSourceForm.HandleUrlChange(0, initialId);
                autoDataSourceForm.RefreshUI();
                StateHasChanged();
            }
        }
    }

    private void OnRegistrationErrorOccurred(object? sender, string errorMessage)
    {
        InvokeAsync(() =>
        {
            registrationErrorMessage = errorMessage;
            showRegistrationError = true;
            isAuthenticated = false;
            StateHasChanged();
        });
    }

    private async Task CloseRegistrationErrorDialog()
    {
        showRegistrationError = false;
        registrationErrorMessage = null;
        StateHasChanged();
        
        // Refresh the page to restart the authentication flow
        await Task.Delay(100); // Small delay to allow UI to update
        NavigationManager.NavigateTo("/", forceLoad: true);
    }

    public void Dispose()
    {
        // Unsubscribe from registration error events
        RegistrationErrorService.RegistrationErrorOccurred -= OnRegistrationErrorOccurred;
    }
}
