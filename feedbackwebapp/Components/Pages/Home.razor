@page "/"
@namespace FeedbackWebApp.Components.Pages

@using System.Web
@using Microsoft.AspNetCore.Components
@using Microsoft.JSInterop
@using FeedbackWebApp.Components.Feedback.Forms
@using FeedbackWebApp.Components.Feedback.Results
@using FeedbackWebApp.Services.Interfaces
@using FeedbackWebApp.Services.Feedback
@using FeedbackWebApp.Services.Authentication
@using FeedbackWebApp.Services
@using FeedbackWebApp.Components.Shared
@using SharedDump.Models
@using SharedDump.Models.Account
@using SharedDump.Models.BlueSkyFeedback
@using SharedDump.Models.DevBlogs
@using SharedDump.Models.GitHub
@using SharedDump.Models.HackerNews
@using SharedDump.Models.Reddit
@using SharedDump.Models.TwitterFeedback
@using SharedDump.Models.YouTube
@using SharedDump.Utils
@using SharedDump.Services
@using SharedDump.AI

@inject IConfiguration Configuration
@inject FeedbackServiceProvider ServiceProvider
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager
@inject UserSettingsService UserSettings
@inject IHistoryService HistoryService
@inject IAuthenticationService AuthService
@inject IRegistrationErrorService RegistrationErrorService
@inject ITwitterAccessService TwitterAccessService
@implements IDisposable

<PageTitle>Feedback Analysis - FeedbackFlow</PageTitle>

<NewFeaturesDialog 
    IsVisible="@showNewFeaturesDialog" 
    OnClose="@CloseNewFeaturesDialog"
    OnGotIt="@MarkNewFeaturesAsSeen" 
    OnRemindLater="@CloseNewFeaturesDialog" />

<UsageLimitDialog 
    UsageError="@usageLimitError" 
    IsVisible="@showUsageLimitDialog" 
    OnClose="@CloseUsageLimitDialog" />

<RegistrationErrorDialog 
    IsVisible="@showRegistrationError" 
    ErrorMessage="@registrationErrorMessage" 
    OnClose="@CloseRegistrationErrorDialog" />

<div class="container">
    @if (!isAuthenticated)
    {
        <AuthenticationForm OnAuthenticatedWithDetails="HandleAuthenticatedWithDetails" />
    }
    else
    {        
        <div class="d-flex justify-content-between align-items-center mb-4 flex-wrap gap-2">
            <div class="d-flex align-items-center gap-2">
                <h1 class="feedbackflow-title mb-0">Analyze</h1>
                <span class="ai-badge" title="AI model powering the analysis">Powered by GPT-5</span>
            </div>
            <SourceSelector @bind-SelectedSource="selectedSource" IsDisabled="@isLoading" />
        </div>

        @if (selectedSource == "Auto")
        {
            <PlatformPills />
        }

        @if (!string.IsNullOrEmpty(selectedSource))
        {            
            <div class="card shadow-sm">
                <div class="card-body">
                    @if (selectedSource.Equals("Auto", StringComparison.OrdinalIgnoreCase))
                    {
                        <AutoDataSourceForm @ref="autoDataSourceForm" IsDisabled="@isLoading" OnUrlsChanged="HandleUrlsChanged" @bind-IncludeIndividualReports="includeIndividualReports" />
                    }
                    else if (selectedSource.Equals("Manual", StringComparison.OrdinalIgnoreCase))
                    {
                        <ManualFeedbackInput @ref="manualInputForm" IsDisabled="@isLoading" />
                    }

                    @* Customize Prompt (only for Auto mode; manual mode has its own system prompt input) *@
                    @if (selectedSource.Equals("Auto", StringComparison.OrdinalIgnoreCase))
                    {
                        <div class="mt-3">
                            <div class="mb-3">
                                <label class="form-label fw-semibold">Analysis Type</label>
                                <select class="form-select" @bind="selectedPromptType" @bind:after="OnPromptTypeChanged" disabled="@isLoading">
                                    <option value="@SharedDump.AI.PromptType.ProductFeedback">Product Feedback Analysis</option>
                                    <option value="@SharedDump.AI.PromptType.CompetitorAnalysis">Competitor Analysis</option>
                                    <option value="@SharedDump.AI.PromptType.GeneralAnalysis">General Analysis</option>
                                    <option value="@SharedDump.AI.PromptType.Custom">Custom Prompt</option>
                                </select>
                                <div class="form-text">
                                    @if (selectedPromptType == SharedDump.AI.PromptType.ProductFeedback)
                                    {
                                        <text>Analyzes feedback as if it's about YOUR product, focusing on improvements and user needs.</text>
                                    }
                                    else if (selectedPromptType == SharedDump.AI.PromptType.CompetitorAnalysis)
                                    {
                                        <text>Analyzes competitor products to extract competitive intelligence and differentiation opportunities.</text>
                                    }
                                    else if (selectedPromptType == SharedDump.AI.PromptType.GeneralAnalysis)
                                    {
                                        <text>Provides neutral, objective analysis without product or competitive context.</text>
                                    }
                                    else if (selectedPromptType == SharedDump.AI.PromptType.Custom)
                                    {
                                        <text>Uses your custom prompt from settings for personalized analysis.</text>
                                    }
                                </div>
                            </div>
                            <button type="button" class="btn btn-sm btn-outline-secondary" @onclick="TogglePromptEditor" disabled="@isLoading">
                                <i class="bi bi-sliders me-1"></i>
                                @(showPromptEditor ? "Hide Prompt Editor" : "Customize Prompt")
                            </button>
                        </div>
                        @if (showPromptEditor)
                        {
                            <div class="mt-3 custom-prompt-editor">
                                <label class="form-label fw-semibold">Customize Prompt</label>
                                <textarea class="form-control" rows="5" @bind="customPrompt" @bind:event="oninput" @bind:after="OnPromptModified" placeholder="Customize the analysis prompt..." disabled="@isLoading"></textarea>
                                <div class="form-text d-flex justify-content-between">
                                    <span>@(promptModified ? "Modified - will be sent to backend" : "Not modified - using " + selectedPromptType.ToString())</span>
                                    @if (!string.IsNullOrWhiteSpace(customPrompt))
                                    {
                                        <button type="button" class="btn btn-sm btn-outline-secondary" @onclick="ResetCustomPrompt" disabled="@isLoading" title="Clear temporary prompt">
                                            <i class="bi bi-x-circle"></i> Reset
                                        </button>
                                    }
                                </div>
                            </div>
                        }
                    }

                    @* Multi-step buttons for Auto mode *@
                    @if (selectedSource.Equals("Auto", StringComparison.OrdinalIgnoreCase))
                    {
                        <div class="multi-step-buttons mt-3">
                            <div class="d-flex gap-2 flex-wrap">
                                @* Step 1: Get Comments Button *@
                                <button class="btn btn-primary btn-lg flex-grow-1 action-btn" 
                                        @onclick="FetchCommentsAsync" 
                                        disabled="@(isLoading || (autoDataSourceForm?.GetUrls()?.Any(u => !string.IsNullOrWhiteSpace(u)) != true))">
                                    @if (isFetchingComments)
                                    {
                                        <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
                                        <span>Fetching Comments...</span>
                                    }
                                    else
                                    {
                                        <i class="bi bi-cloud-download me-2"></i>
                                        <span>@(hasComments ? "Refresh Comments" : "Get Comments")</span>
                                    }
                                </button>

                                @* Step 2: Analyze Comments Button (enabled after fetch) *@
                                <button class="btn @(canAnalyze ? "btn-success" : "btn-outline-secondary") btn-lg flex-grow-1 action-btn" 
                                        @onclick="AnalyzeCommentsAsync" 
                                        disabled="@(!canAnalyze)">
                                    @if (isAnalyzing)
                                    {
                                        <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
                                        <span>Analyzing...</span>
                                    }
                                    else
                                    {
                                        <i class="bi bi-lightning-charge me-2"></i>
                                        <span>@(!string.IsNullOrEmpty(markdownResult) ? "Re-analyze" : "Analyze Comments")</span>
                                    }
                                </button>
                            </div>

                            @* Comment count badge and warning *@
                            @if (hasComments)
                            {
                                <div class="comment-status-bar mt-3">
                                    <div class="d-flex align-items-center gap-2 flex-wrap">
                                        <span class="badge bg-primary comment-count-badge">
                                            <i class="bi bi-chat-dots me-1"></i>
                                            @cachedCommentCount.ToString("N0") comments fetched
                                        </span>
                                        
                                        @* Export button for fetched comments *@
                                        <ExportButton Items="@(new[] { CreateExportItemFromComments() })" 
                                                      ButtonVariant="secondary" 
                                                      Size="sm" />
                                    </div>
                                </div>
                            }
                        </div>
                    }
                    else
                    {
                        @* Manual mode: single submit button *@
                        <SubmitButton ShowWhenSource="@selectedSource" IsLoading="@isLoading" OnSubmit="SubmitManualFeedbackRequest" ButtonText="Analyze" />
                    }
                    
                    @if (isLoading)
                    {
                        <div class="alert alert-info mt-3">
                            <div class="d-flex align-items-center">
                                <div class="spinner-border spinner-border-sm me-2" role="status"></div>
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            <div>
                                <strong>@currentStatus</strong>
                                <div class="small">@currentStatusMessage</div>
                            </div>
                        </div>
                    }

                    @* Show fetched comments before analysis (Auto mode) *@
                    @if (hasComments && fetchedThreads != null && fetchedThreads.Any() && selectedSource.Equals("Auto", StringComparison.OrdinalIgnoreCase))
                    {
                        <div class="fetched-comments-section mt-4">
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <h5 class="mb-0">
                                    <i class="bi bi-collection me-2"></i>
                                    Fetched Comments Preview
                                </h5>
                                @if (!string.IsNullOrEmpty(markdownResult))
                                {
                                    <span class="badge bg-success">
                                        <i class="bi bi-check-circle me-1"></i>Analyzed
                                    </span>
                                }
                            </div>
                            <ThreadResults Threads="fetchedThreads" GroupBySourceType="true" />
                        </div>
                    }
                        
                    <AnalysisResults 
                        Error="@error" 
                        MarkdownResult="@markdownResult" 
                        SourceType="@selectedSourceFinal"
                        UserInput="@GetUserInputForSource()"
                        AdditionalData="@GetAdditionalDataForAnalysis()" /> 

                    @* Discreet survey link (desktop only) *@
                    <SurveyLink IsVisible="@showSurveyLink" OnSurveyClicked="@OnSurveyLinkClicked" />

                    @* Display additional data from FeedbackSourceData list (for Manual mode) *@
                    @if (!selectedSource.Equals("Auto", StringComparison.OrdinalIgnoreCase) && feedbackSources != null && feedbackSources.Any())
                    {
                        @* Use unified threading components *@
                        var allThreads = GetUnifiedThreadsFromSources(feedbackSources);
                        if (allThreads.Any())
                        {
                            <ThreadResults Threads="allThreads" GroupBySourceType="true" />
                        }
                    }
                </div>
            </div>
        }
    }
</div>

@code {
    private AutoDataSourceForm? autoDataSourceForm;
    private ManualFeedbackInput? manualInputForm;
    private string selectedSource = "Auto";
    private string? lastSelectedSource = "Auto";  // Track for invalidation
    private string markdownResult = "";
    private string error = "";
    private bool isLoading = false;
    private bool isAuthenticated = false;
    private bool showNewFeaturesDialog = false;
    private bool showUsageLimitDialog = false;
    private bool showRegistrationError = false;
    private string? registrationErrorMessage = null;
    private UsageValidationResult? usageLimitError;
    private List<FeedbackSourceData>? feedbackSources;
    private object? currentAdditionalData;
    private FeedbackProcessStatus currentStatus;
    private string currentStatusMessage = "";
    private string? initialSource;
    private string? initialId;
    private List<string>? initialUrls;
    private bool showPromptEditor = false;
    private string customPrompt = string.Empty; // Temporary, not persisted
    private string originalPrompt = string.Empty; // Track the original prompt for the selected type
    private bool promptModified = false; // Track if user has modified the prompt
    private bool showSurveyLink = false; // After successful analysis and if not previously completed
    private bool includeIndividualReports = false; // Default to false - only full report
    private SharedDump.AI.PromptType currentPromptType = SharedDump.AI.PromptType.ProductFeedback;
    private SharedDump.AI.PromptType selectedPromptType = SharedDump.AI.PromptType.ProductFeedback; // User-selected prompt type for this analysis
    private bool useCustomPrompts = false;
    
    // Multi-step flow state
    private bool hasComments = false;
    private bool isFetchingComments = false;
    private bool isAnalyzing = false;
    private List<CommentThread>? fetchedThreads;
    // Reanalyze caching state
    private string[]? lastAnalyzedUrls;
    private string? cachedComments;
    private int cachedCommentCount;
    private object? cachedAdditionalData;
    
    // Computed property for enabling analyze button
    private bool canAnalyze => hasComments && cachedComments != null && !isLoading;
    
    private static string Truncate(string value, int max)
        => string.IsNullOrEmpty(value) || value.Length <= max ? value : value.Substring(0, max) + "...";

    private void TogglePromptEditor()
    {
        showPromptEditor = !showPromptEditor;
        if (showPromptEditor && selectedSource.Equals("Auto", StringComparison.OrdinalIgnoreCase))
        {
            // When opening the editor, load the prompt for the currently selected type
            LoadPromptForSelectedType();
        }
    }

    private async void LoadPromptForSelectedType()
    {
        if (selectedPromptType == SharedDump.AI.PromptType.Custom)
        {
            // Load custom prompt from settings
            await PrefillPromptFromSettingsAsync();
        }
        else
        {
            // Load the prompt for the selected type
            customPrompt = FeedbackAnalyzerService.GetPromptByType(selectedPromptType);
        }
        
        // Store the original prompt to track modifications
        originalPrompt = customPrompt;
        promptModified = false;
        StateHasChanged();
    }

    private void OnPromptModified()
    {
        // Track if the user has modified the prompt from the original
        promptModified = customPrompt != originalPrompt;
    }

    private async Task PrefillPromptFromSettingsAsync()
    {
        try
        {
            var settings = await UserSettings.GetSettingsAsync();
            currentPromptType = settings.SelectedPromptType;
            selectedPromptType = settings.SelectedPromptType; // Initialize selected prompt type with user's default
            useCustomPrompts = settings.UseCustomPrompts;
            if (!string.IsNullOrWhiteSpace(settings.UniversalPrompt))
            {
                customPrompt = settings.UniversalPrompt;
                StateHasChanged();
            }
        }
        catch { /* swallow - non critical */ }
    }

    private Task ResetCustomPrompt()
    {
        customPrompt = originalPrompt;
        promptModified = false;
        showPromptEditor = false;
        return Task.CompletedTask;
    }

    private async Task OnPromptTypeChanged()
    {
        // When analysis type changes, update the custom prompt textarea
        if (selectedPromptType == SharedDump.AI.PromptType.Custom)
        {
            // Load custom prompt from settings
            try
            {
                var settings = await UserSettings.GetSettingsAsync();
                if (!string.IsNullOrWhiteSpace(settings.UniversalPrompt))
                {
                    customPrompt = settings.UniversalPrompt;
                }
                else
                {
                    customPrompt = string.Empty;
                }
            }
            catch { /* swallow - non critical */ }
        }
        else
        {
            // Load the prompt for the selected type
            customPrompt = FeedbackAnalyzerService.GetPromptByType(selectedPromptType);
        }
        
        // Store the original prompt and reset modification flag
        originalPrompt = customPrompt;
        promptModified = false;
        StateHasChanged();
    }

    /// <summary>
    /// Applies the appropriate prompt to the service based on user selection and modifications.
    /// Priority: modified prompt > custom prompt type > prompt type name (efficient)
    /// </summary>
    private void ApplyPromptToService(IFeedbackService service)
    {
        // Determine what to send:
        // - If user modified the prompt OR selected Custom prompt type, send the full customPrompt
        // - Otherwise, don't set a temporary prompt (FeedbackService will send promptType name)
        if (promptModified || selectedPromptType == SharedDump.AI.PromptType.Custom)
        {
            // User modified the prompt or is using custom prompt - send the full prompt text
            if (!string.IsNullOrWhiteSpace(customPrompt))
            {
                service.SetTemporaryPrompt(customPrompt);
            }
            else if (selectedPromptType == SharedDump.AI.PromptType.Custom)
            {
                // Custom selected but prompt is empty - load from settings
                service.SetTemporaryPrompt(customPrompt);
            }
        }
        else
        {
            // Using a standard prompt type without modifications
            // Don't set temporary prompt - let FeedbackService send the promptType name
            service.ClearTemporaryPrompt();
        }
    }

    // URL normalization and comparison helpers for reanalyze feature
    private string[] NormalizeUrls(IEnumerable<string> urls) => urls
        .Where(u => !string.IsNullOrWhiteSpace(u))
        .Select(u => u.Trim().ToLowerInvariant()) // Normalize casing  
        .Distinct()
        .OrderBy(u => u)
        .ToArray();

    private bool UrlsUnchanged()
    {
        var current = NormalizeUrls(autoDataSourceForm?.GetUrls() ?? Enumerable.Empty<string>());
        return lastAnalyzedUrls != null && current.SequenceEqual(lastAnalyzedUrls);
    }

    private void InvalidateCache()
    {
        lastAnalyzedUrls = null;
        cachedComments = null;
        cachedCommentCount = 0;
        cachedAdditionalData = null;
        hasComments = false;
        fetchedThreads = null;
        markdownResult = "";
        feedbackSources = null;
    }

    private Task HandleUrlsChanged(List<string> urls)
    {
        // Invalidate cache when URLs change
        if (selectedSource.Equals("Auto", StringComparison.OrdinalIgnoreCase))
        {
            var normalizedUrls = NormalizeUrls(urls);
            if (lastAnalyzedUrls != null && !normalizedUrls.SequenceEqual(lastAnalyzedUrls))
            {
                InvalidateCache();
            }
        }
        StateHasChanged();
        return Task.CompletedTask;
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        
        // Check if source changed and invalidate cache if needed
        if (lastSelectedSource != null && !string.Equals(lastSelectedSource, selectedSource, StringComparison.OrdinalIgnoreCase))
        {
            if (!selectedSource.Equals("Auto", StringComparison.OrdinalIgnoreCase))
            {
                InvalidateCache();
            }
        }
        lastSelectedSource = selectedSource;
    }

    bool isAuthenticating = false;
    private async Task HandleAuthenticatedWithDetails((bool success, bool justLoggedIn) details)
    {
        isAuthenticated = details.success;
        StateHasChanged();

        if (details.success && !isAuthenticating)
        {
            // Only handle post-login registration if the user just logged in
            // This avoids unnecessary backend calls when user was already authenticated
            if (details.justLoggedIn)
            {
                try
                {
                    isAuthenticating = true;
                    await AuthService.HandlePostLoginRegistrationAsync();
                }
                catch (Exception ex)
                {
                    // Log but don't fail the authentication flow if registration has issues
                    Console.WriteLine($"Post-login registration warning: {ex.Message}");
                }
                finally
                {
                    isAuthenticating = false;
                }
            }

            await HandleQueryNav();
            //await CheckForNewFeatures();
        }
    }

   
    private async Task CheckForNewFeatures()
    {

        try
        {
            // Check if user has history (indicating they've used the app before)
            var hasHistory = (await HistoryService.GetHistoryCountAsync()) > 0;
            
            // Only show new features dialog if user has history and hasn't seen latest features
            if (hasHistory && await UserSettings.ShouldShowFeatureAnnouncementAsync())
            {
                // Add a small delay to let the page fully render
                await Task.Delay(1000);
                showNewFeaturesDialog = true;
                StateHasChanged();
            }
            else 
            {
                // if they are a new user or have seen the announcement, mark it as shown
                await UserSettings.MarkFeatureAnnouncementShownAsync();
            }
        }
        catch (Exception)
        {
            // If anything fails, silently continue without showing the dialog
        }
    }

    private void CloseNewFeaturesDialog()
    {
        showNewFeaturesDialog = false;
        StateHasChanged();
    }

    private async Task MarkNewFeaturesAsSeen()
    {
        await UserSettings.MarkFeatureAnnouncementShownAsync();
        CloseNewFeaturesDialog();
    }

    private void CloseUsageLimitDialog()
    {
        showUsageLimitDialog = false;
        usageLimitError = null;
        StateHasChanged();
    }

    private void HandleStatusUpdate(FeedbackProcessStatus status, string message)
    {
        currentStatus = status;
        currentStatusMessage = message;
        StateHasChanged();
    }

    private string? GetUserInputForSource()
    {
        return selectedSource switch
        {
            "Manual" => manualInputForm?.ContentInput,
            "Auto" => autoDataSourceForm?.GetUrls() is { } urls && urls.Any() ? string.Join(", ", urls) : null,
            _ => null
        };
    }

    private object? GetAdditionalDataForAnalysis()
    {
        // For Auto source type, extract additional data from feedbackSources
        if (selectedSource == "Auto" && feedbackSources != null)
        {
            // Combine all additional data from all sources
            var allAdditionalData = feedbackSources
                .Where(source => source.AdditionalData != null)
                .Select(source => source.AdditionalData)
                .ToList();

            // If there's only one type of data, return it directly
            if (allAdditionalData.Count == 1)
            {
                return allAdditionalData[0];
            }
            
            // If there are multiple types, return them as a list
            if (allAdditionalData.Count > 1)
            {
                return allAdditionalData;
            }
        }

        // For other source types, return the raw additional data
        return currentAdditionalData;
    }

    private string selectedSourceFinal => selectedSource.Equals("Auto", StringComparison.OrdinalIgnoreCase)
        ? GetSourcesFromUrls()
        : selectedSource;

    private string GetSourcesFromUrls()
    {
        if (autoDataSourceForm?.GetUrls() is not { } urls || !urls.Any())
            return "Auto";
            
        var sources = new List<string>();
        
        foreach (var url in urls)
        {
            if (string.IsNullOrWhiteSpace(url))
                continue;
                
            if (UrlParsing.IsYouTubeUrl(url))
                sources.Add("YouTube");
            else if (url.Contains("reddit.com"))
                sources.Add("Reddit");
            else if (url.Contains("news.ycombinator.com") || url.Contains("hackernews"))
                sources.Add("HackerNews");
            else if (url.Contains("github.com"))
                sources.Add("GitHub");
            else if (url.Contains("devblogs.microsoft.com"))
                sources.Add("DevBlogs");
            else if (url.Contains("bsky.app"))
                sources.Add("BlueSky");
            else
                sources.Add("Web");
        }
        
        // Return unique sources as comma-separated list, or "Auto" if no sources identified
        return sources.Distinct().Any() ? string.Join(", ", sources.Distinct()) : "Auto";
    }


    /// <summary>
    /// Fetches comments from URLs without analyzing them (Auto mode only)
    /// </summary>
    private async Task FetchCommentsAsync()
    {
        if (!selectedSource.Equals("Auto", StringComparison.OrdinalIgnoreCase))
            return;

        try
        {
            // Reset previous data but preserve any existing analysis for re-fetch scenario
            error = "";
            markdownResult = "";
            feedbackSources = null;
            currentAdditionalData = null;
            hasComments = false;
            fetchedThreads = null;
            isFetchingComments = true;
            isLoading = true;
            currentStatus = FeedbackProcessStatus.GatheringComments;
            currentStatusMessage = "Fetching comments...";
            showSurveyLink = false;
            StateHasChanged();

            var urls = autoDataSourceForm?.GetUrls() ?? new List<string>();
            
            // Check Twitter access before fetching
            var (hasAccess, accessError) = await TwitterAccessService.CheckTwitterAccessAsync(urls);
            if (!hasAccess && !string.IsNullOrEmpty(accessError))
            {
                error = accessError;
                return;
            }

            // Create service for fetching
            var service = ServiceProvider.CreateAutoDataSourceService(
                urls.ToArray(),
                HandleStatusUpdate);

            // Only fetch comments, don't analyze
            var (rawComments, commentCount, additionalData) = await service.GetComments();
            
            // Cache the fetched data
            lastAnalyzedUrls = NormalizeUrls(urls);
            cachedComments = rawComments;
            cachedCommentCount = commentCount;
            cachedAdditionalData = additionalData;
            hasComments = true;

            // Handle feedbackSources for display
            if (additionalData is List<FeedbackSourceData> sources)
            {
                feedbackSources = sources;
                fetchedThreads = GetUnifiedThreadsFromSources(sources);
            }

            currentStatusMessage = $"Fetched {commentCount} comments from {urls.Count} source(s)";
        }
        catch (UsageLimitExceededException ex)
        {
            usageLimitError = ex.LimitError;
            showUsageLimitDialog = true;
        }
        catch (Exception ex)
        {
            if (UsageLimitErrorHelper.TryParseUsageLimitError(ex.Message, out var limitError))
            {
                usageLimitError = limitError;
                showUsageLimitDialog = true;
            }
            else
            {
                error = $"Failed to fetch comments: {ex.Message}";
            }
        }
        finally
        {
            isFetchingComments = false;
            isLoading = false;
            currentStatus = FeedbackProcessStatus.Completed;
            StateHasChanged();
        }
    }

    /// <summary>
    /// Analyzes previously fetched comments (Auto mode only)
    /// </summary>
    private async Task AnalyzeCommentsAsync()
    {
        if (!canAnalyze || cachedComments is null)
            return;

        try
        {
            error = "";
            markdownResult = "";
            isAnalyzing = true;
            isLoading = true;
            currentStatus = FeedbackProcessStatus.AnalyzingComments;
            currentStatusMessage = "Analyzing comments...";
            showSurveyLink = false;
            StateHasChanged();

            // Create service for analysis
            var service = ServiceProvider.CreateAutoDataSourceService(
                autoDataSourceForm?.GetUrls().ToArray() ?? Array.Empty<string>(),
                HandleStatusUpdate);

            // Set the individual reports flag
            var autoService = service as IAutoDataSourceFeedbackService;
            autoService?.SetIncludeIndividualReports(includeIndividualReports);

            // Apply the appropriate prompt
            ApplyPromptToService(service);

            // Analyze the cached comments
            var (result, additionalData) = await service.AnalyzeComments(cachedComments, cachedCommentCount, cachedAdditionalData);
            markdownResult = result;
            currentAdditionalData = additionalData;

            // Update feedbackSources if new data returned
            if (additionalData is List<FeedbackSourceData> sources)
            {
                feedbackSources = sources;
            }
        }
        catch (UsageLimitExceededException ex)
        {
            usageLimitError = ex.LimitError;
            showUsageLimitDialog = true;
        }
        catch (Exception ex)
        {
            if (UsageLimitErrorHelper.TryParseUsageLimitError(ex.Message, out var limitError))
            {
                usageLimitError = limitError;
                showUsageLimitDialog = true;
            }
            else
            {
                error = $"Failed to analyze comments: {ex.Message}";
            }
        }
        finally
        {
            isAnalyzing = false;
            isLoading = false;
            currentStatus = FeedbackProcessStatus.Completed;
            currentStatusMessage = "";
            
            // Show survey link on successful analysis
            if (string.IsNullOrEmpty(error) && !string.IsNullOrWhiteSpace(markdownResult))
            {
                try
                {
                    if (UserSettings.IsSurveyEnabled())
                    {
                        var hasCompletedSurvey = await UserSettings.HasCompletedSurveyAsync();
                        if (!hasCompletedSurvey)
                        {
                            showSurveyLink = true;
                        }
                    }
                }
                catch { /* ignore */ }
            }
            StateHasChanged();
        }
    }

    /// <summary>
    /// Handles Manual mode submission (fetches and analyzes in one step)
    /// </summary>
    private async Task SubmitManualFeedbackRequest()
    {
        if (!selectedSource.Equals("Manual", StringComparison.OrdinalIgnoreCase))
            return;

        try
        {
            error = "";
            markdownResult = "";
            feedbackSources = null;
            currentAdditionalData = null;
            isLoading = true;
            currentStatus = FeedbackProcessStatus.GatheringComments;
            currentStatusMessage = "Processing...";
            showSurveyLink = false;
            StateHasChanged();

            var service = ServiceProvider.CreateManualService(
                manualInputForm?.GetContent() ?? string.Empty,
                manualInputForm?.GetSystemPrompt(),
                HandleStatusUpdate);

            var (result, additionalData) = await service.GetFeedback();
            markdownResult = result;
            currentAdditionalData = additionalData;
        }
        catch (UsageLimitExceededException ex)
        {
            usageLimitError = ex.LimitError;
            showUsageLimitDialog = true;
        }
        catch (Exception ex)
        {
            if (UsageLimitErrorHelper.TryParseUsageLimitError(ex.Message, out var limitError))
            {
                usageLimitError = limitError;
                showUsageLimitDialog = true;
            }
            else
            {
                error = $"An error occurred: {ex.Message}";
            }
        }
        finally
        {
            await Task.Delay(500);
            isLoading = false;
            currentStatus = FeedbackProcessStatus.Completed;
            currentStatusMessage = "";
            
            if (string.IsNullOrEmpty(error) && !string.IsNullOrWhiteSpace(markdownResult))
            {
                try
                {
                    if (UserSettings.IsSurveyEnabled())
                    {
                        var hasCompletedSurvey = await UserSettings.HasCompletedSurveyAsync();
                        if (!hasCompletedSurvey)
                        {
                            showSurveyLink = true;
                        }
                    }
                }
                catch { /* ignore */ }
            }
            StateHasChanged();
        }
    }

    protected override async Task OnInitializedAsync()
    {
        // Subscribe to registration error events
        RegistrationErrorService.RegistrationErrorOccurred += OnRegistrationErrorOccurred;
        
        var uri = new Uri(NavigationManager.Uri);
        var query = System.Web.HttpUtility.ParseQueryString(uri.Query);

        // Check if this is an OAuth redirect (user just completed login)
        var isOAuthRedirect = !string.IsNullOrEmpty(query["code"]) || 
                             !string.IsNullOrEmpty(query["state"]) ||
                             uri.AbsolutePath.Contains("/.auth/login/");

        // Store auth status for later processing in OnAfterRenderAsync
        var authStatus = query["auth"];
        if (authStatus == "failed" || authStatus == "error")
        {
            // Store the auth error status to handle in OnAfterRenderAsync
            await Task.CompletedTask; // Placeholder - will handle in OnAfterRenderAsync
        }

        initialSource = query["source"]?.ToLower();
        initialId = query["id"];
        
        // Check for multiple URL parameters
        var urlParams = query.GetValues("url");
        if (urlParams != null && urlParams.Length > 0)
        {
            initialSource = "auto";
            initialUrls = urlParams.Where(u => !string.IsNullOrWhiteSpace(u)).ToList();
            // For backward compatibility, also set initialId to the first URL if only one is provided
            if (initialUrls.Count == 1)
            {
                initialId = initialUrls[0];
            }
        }
        else
        {
            var url = query["url"];
            // If single URL is provided, switch to Auto mode and use the URL
            if (!string.IsNullOrEmpty(url))
            {
                initialSource = "auto";
                initialId = url;
            }
        }

        // If this is an OAuth redirect, check authentication and handle post-login registration
        if (isOAuthRedirect)
        {
            try
            {
                // Give time for OAuth tokens to settle
                await Task.Delay(500);
                
                var isAuthenticated = await AuthService.IsAuthenticatedAsync();
                if (isAuthenticated)
                {
                    // This is a fresh OAuth login, handle post-login registration
                    await HandleAuthenticatedWithDetails((true, true));
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"OAuth redirect handling error: {ex.Message}");
            }
        }

        // Load user settings for prompt type
        await PrefillPromptFromSettingsAsync();

        await base.OnInitializedAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Handle authentication error logging after render
            var uri = new Uri(NavigationManager.Uri);
            var query = System.Web.HttpUtility.ParseQueryString(uri.Query);
            var authStatus = query["auth"];
            
            if (authStatus == "failed")
            {
                // Show authentication failed message
                await JSRuntime.InvokeVoidAsync("console.log", "Authentication failed");
            }
            else if (authStatus == "error")
            {
                // Show authentication error message
                await JSRuntime.InvokeVoidAsync("console.log", "Authentication error occurred");
            }
        }
    }    
    
    private async Task HandleQueryNav()
    {
        // Check if we have multiple URLs or a single URL
        var hasMultipleUrls = initialUrls != null && initialUrls.Count > 0;
        var hasSingleUrl = !string.IsNullOrEmpty(initialId);
        
        if (string.IsNullOrEmpty(initialSource) || (!hasMultipleUrls && !hasSingleUrl))
            return;

        selectedSource = initialSource.ToLower() switch
        {
            "auto" or "hackernews" or "reddit" or "youtube" => "Auto",
            _ => selectedSource
        };
        StateHasChanged();        
        if (selectedSource == "Auto")
        {
            // Wait for autoDataSourceForm to be initialized, up to 10 attempts
            var attempts = 0;
            while (autoDataSourceForm is null && attempts < 10)
            {
                await Task.Delay(250);
                attempts++;
            }

            if (autoDataSourceForm is not null)
            {
                if (hasMultipleUrls)
                {
                    // Handle multiple URLs
                    for (int i = 0; i < initialUrls!.Count; i++)
                    {
                        if (i > 0)
                        {
                            // Add new URL input fields for additional URLs
                            await autoDataSourceForm.HandleUrlChange(i, initialUrls[i]);
                        }
                        else
                        {
                            // Set the first URL
                            await autoDataSourceForm.HandleUrlChange(0, initialUrls[i]);
                        }
                    }
                }
                else if (hasSingleUrl)
                {
                    // Handle single URL (backward compatibility)
                    await autoDataSourceForm.HandleUrlChange(0, initialId!);
                }
                
                autoDataSourceForm.RefreshUI();
                StateHasChanged();
            }
        }
    }

    private void OnRegistrationErrorOccurred(object? sender, string errorMessage)
    {
        InvokeAsync(() =>
        {
            registrationErrorMessage = errorMessage;
            showRegistrationError = true;
            isAuthenticated = false;
            StateHasChanged();
        });
    }

    private async Task CloseRegistrationErrorDialog()
    {
        showRegistrationError = false;
        registrationErrorMessage = null;
        StateHasChanged();
        
        // Refresh the page to restart the authentication flow
        await Task.Delay(100); // Small delay to allow UI to update
        NavigationManager.NavigateTo("/", forceLoad: true);
    }

    private List<SharedDump.Models.CommentThread> GetUnifiedThreadsFromSources(List<FeedbackSourceData> sources)
    {
        var allThreads = new List<SharedDump.Models.CommentThread>();

        foreach (var source in sources)
        {
            if (source.AdditionalData != null)
            {
                List<SharedDump.Models.CommentThread> convertedThreads;
                
                // Handle HackerNewsAnalysis specifically since it's in the web app project
                if (source.AdditionalData is List<HackerNewsAnalysis> analyses)
                {
                    convertedThreads = HackerNewsCommentConverter.ConvertHackerNewsAnalysis(analyses);
                }
                else
                {
                    convertedThreads = CommentDataConverter.ConvertAdditionalData(source.AdditionalData);
                }
                
                allThreads.AddRange(convertedThreads);
            }
        }

        return allThreads;
    }

    /// <summary>
    /// Creates an export item from fetched comments (before analysis)
    /// </summary>
    private AnalysisHistoryItem CreateExportItemFromComments()
    {
        var urls = autoDataSourceForm?.GetUrls() ?? new List<string>();
        var sourceTypes = GetSourcesFromUrls();
        
        return new AnalysisHistoryItem
        {
            Id = Guid.NewGuid().ToString(),
            FullAnalysis = $"# Raw Comments Export\n\nExported {cachedCommentCount} comments from {urls.Count} source(s).\n\n**Sources:** {sourceTypes}\n\n**URLs:**\n{string.Join("\n", urls.Select(u => $"- {u}"))}",
            SourceType = sourceTypes,
            UserInput = string.Join(", ", urls),
            Timestamp = DateTime.UtcNow,
            CommentThreads = fetchedThreads ?? new List<CommentThread>()
        };
    }

    public void Dispose()
    {
        // Unsubscribe from registration error events
        RegistrationErrorService.RegistrationErrorOccurred -= OnRegistrationErrorOccurred;
    }

    private Task OnSurveyLinkClicked()
    {
        // Hide the survey link in the parent component
        showSurveyLink = false;
        StateHasChanged();
        return Task.CompletedTask;
    }
}

@code {
    // Extension helper pattern inside the same file (scoped) to avoid broad changes
}
