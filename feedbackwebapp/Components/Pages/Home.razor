@page "/"
@* Updated to handle single URLs instead of comma-separated lists *@
@namespace FeedbackWebApp.Components.Pages

@using System.Web
@using Microsoft.AspNetCore.Components
@using Microsoft.JSInterop
@using FeedbackWebApp.Components.Feedback.Forms
@using FeedbackWebApp.Components.Feedback.Results
@using FeedbackWebApp.Services.Interfaces
@using FeedbackWebApp.Services.Feedback
@using FeedbackWebApp.Services.Authentication
@using FeedbackWebApp.Services
@using FeedbackWebApp.Components.Shared
@using SharedDump.Models
@using SharedDump.Models.Account
@using SharedDump.Models.BlueSkyFeedback
@using SharedDump.Models.DevBlogs
@using SharedDump.Models.GitHub
@using SharedDump.Models.HackerNews
@using SharedDump.Models.Reddit
@using SharedDump.Models.TwitterFeedback
@using SharedDump.Models.YouTube
@using SharedDump.Utils
@using SharedDump.Services

@inject IConfiguration Configuration
@inject FeedbackServiceProvider ServiceProvider
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager
@inject UserSettingsService UserSettings
@inject IHistoryService HistoryService
@inject IAuthenticationService AuthService
@inject IRegistrationErrorService RegistrationErrorService
@inject ITwitterAccessService TwitterAccessService
@implements IDisposable

<PageTitle>Feedback Analysis - FeedbackFlow</PageTitle>

<NewFeaturesDialog 
    IsVisible="@showNewFeaturesDialog" 
    OnClose="@CloseNewFeaturesDialog"
    OnGotIt="@MarkNewFeaturesAsSeen" 
    OnRemindLater="@CloseNewFeaturesDialog" />

<UsageLimitDialog 
    UsageError="@usageLimitError" 
    IsVisible="@showUsageLimitDialog" 
    OnClose="@CloseUsageLimitDialog" />

<RegistrationErrorDialog 
    IsVisible="@showRegistrationError" 
    ErrorMessage="@registrationErrorMessage" 
    OnClose="@CloseRegistrationErrorDialog" />

<div class="container">
    @if (!isAuthenticated)
    {
        <AuthenticationForm OnAuthenticatedWithDetails="HandleAuthenticatedWithDetails" />
    }
    else
    {        
        <div class="d-flex justify-content-between align-items-center mb-4 flex-wrap gap-2">
            <div class="d-flex align-items-center gap-2">
                <h1 class="feedbackflow-title mb-0">Analyze</h1>
                <span class="ai-badge" title="AI model powering the analysis">Powered by GPT-5</span>
            </div>
            <SourceSelector @bind-SelectedSource="selectedSource" IsDisabled="@isLoading" />
        </div>

        @if (selectedSource == "Auto")
        {
            <PlatformPills />
        }

        @if (!string.IsNullOrEmpty(selectedSource))
        {            
            <div class="card shadow-sm">
                <div class="card-body">
                    @if (selectedSource.Equals("Auto", StringComparison.OrdinalIgnoreCase))
                    {
                        <AutoDataSourceForm @ref="autoDataSourceForm" IsDisabled="@isLoading" OnUrlsChanged="HandleUrlsChanged" />
                    }
                    else if (selectedSource.Equals("Manual", StringComparison.OrdinalIgnoreCase))
                    {
                        <ManualFeedbackInput @ref="manualInputForm" IsDisabled="@isLoading" />
                    }

                    @* Customize Prompt (only for Auto mode; manual mode has its own system prompt input) *@
                    @if (selectedSource.Equals("Auto", StringComparison.OrdinalIgnoreCase))
                    {
                        <div class="mt-3">
                            <button type="button" class="btn btn-sm btn-outline-secondary" @onclick="TogglePromptEditor" disabled="@isLoading">
                                <i class="bi bi-sliders me-1"></i>
                                @(showPromptEditor ? "Hide Custom Prompt" : "Customize Prompt")
                            </button>
                        </div>
                        @if (showPromptEditor)
                        {
                            <div class="mt-3 custom-prompt-editor">
                                <label class="form-label fw-semibold">Custom Analysis Prompt (won't be saved)</label>
                                <textarea class="form-control" rows="5" @bind="customPrompt" @bind:event="oninput" placeholder="Add extra instructions for this analysis only..." disabled="@isLoading"></textarea>
                                <div class="form-text d-flex justify-content-between">
                                    <span>This prompt is temporary and will reset when you leave or refresh.</span>
                                    @if (!string.IsNullOrWhiteSpace(customPrompt))
                                    {
                                        <button type="button" class="btn btn-sm btn-outline-secondary" @onclick="ResetCustomPrompt" disabled="@isLoading" title="Clear temporary prompt">
                                            <i class="bi bi-x-circle"></i> Reset
                                        </button>
                                    }
                                </div>
                            </div>
                        }
                    }

                    <SubmitButton ShowWhenSource="@selectedSource" IsLoading="@isLoading" OnSubmit="SubmitFeedbackRequest" ButtonText="@(canReanalyze ? "Reanalyze" : "Analyze Comments")" />
                    
                    @if (isLoading)
                    {
                        <div class="alert alert-info mt-3">
                            <div class="d-flex align-items-center">
                                <div class="spinner-border spinner-border-sm me-2" role="status"></div>
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            <div>
                                <strong>@currentStatus</strong>
                                <div class="small">@currentStatusMessage</div>
                            </div>
                        </div>
                    }                    
                        
                    <AnalysisResults 
                        Error="@error" 
                        MarkdownResult="@markdownResult" 
                        SourceType="@selectedSourceFinal"
                        UserInput="@GetUserInputForSource()"
                        AdditionalData="@GetAdditionalDataForAnalysis()" /> 

                    @* Display additional data from FeedbackSourceData list *@
                    @if (feedbackSources != null && feedbackSources.Any())
                    {
                        @* Use unified threading components *@
                        var allThreads = GetUnifiedThreadsFromSources(feedbackSources);
                        if (allThreads.Any())
                        {
                            <ThreadResults Threads="allThreads" GroupBySourceType="true" />
                        }
                    }
                </div>
            </div>
        }
    }
</div>

@code {
    private AutoDataSourceForm? autoDataSourceForm;
    private ManualFeedbackInput? manualInputForm;
    private string selectedSource = "Auto";
    private string? lastSelectedSource = "Auto";  // Track for invalidation
    private string markdownResult = "";
    private string error = "";
    private bool isLoading = false;
    private bool isAuthenticated = false;
    private bool showNewFeaturesDialog = false;
    private bool showUsageLimitDialog = false;
    private bool showRegistrationError = false;
    private string? registrationErrorMessage = null;
    private UsageValidationResult? usageLimitError;
    private List<FeedbackSourceData>? feedbackSources;
    private object? currentAdditionalData;
    private FeedbackProcessStatus currentStatus;
    private string currentStatusMessage = "";
    private string? initialSource;
    private string? initialId;
    private bool showPromptEditor = false;
    private string customPrompt = string.Empty; // Temporary, not persisted
    
    // Reanalyze caching state
    private string[]? lastAnalyzedUrls;
    private string? cachedComments;
    private int cachedCommentCount;
    private object? cachedAdditionalData;
    
    // Computed property for reanalyze capability
    private bool canReanalyze => cachedComments != null && 
                                lastAnalyzedUrls != null && 
                                selectedSource.Equals("Auto", StringComparison.OrdinalIgnoreCase) &&
                                UrlsUnchanged();

    private static string Truncate(string value, int max)
        => string.IsNullOrEmpty(value) || value.Length <= max ? value : value.Substring(0, max) + "...";

    private void TogglePromptEditor()
    {
        showPromptEditor = !showPromptEditor;
        if (showPromptEditor && string.IsNullOrWhiteSpace(customPrompt) && selectedSource.Equals("Auto", StringComparison.OrdinalIgnoreCase))
        {
            // Prefill with universal/system prompt from settings if available
            _ = PrefillPromptFromSettingsAsync();
        }
    }

    private async Task PrefillPromptFromSettingsAsync()
    {
        try
        {
            var settings = await UserSettings.GetSettingsAsync();
            if (!string.IsNullOrWhiteSpace(settings.UniversalPrompt))
            {
                customPrompt = settings.UniversalPrompt;
                StateHasChanged();
            }
        }
        catch { /* swallow - non critical */ }
    }

    private Task ResetCustomPrompt()
    {
        customPrompt = string.Empty;
        showPromptEditor = false;
        return Task.CompletedTask;
    }

    // URL normalization and comparison helpers for reanalyze feature
    private string[] NormalizeUrls(IEnumerable<string> urls) => urls
        .Where(u => !string.IsNullOrWhiteSpace(u))
        .Select(u => u.Trim().ToLowerInvariant()) // Normalize casing  
        .Distinct()
        .OrderBy(u => u)
        .ToArray();

    private bool UrlsUnchanged()
    {
        var current = NormalizeUrls(autoDataSourceForm?.GetUrls() ?? Enumerable.Empty<string>());
        return lastAnalyzedUrls != null && current.SequenceEqual(lastAnalyzedUrls);
    }

    private void InvalidateCache()
    {
        lastAnalyzedUrls = null;
        cachedComments = null;
        cachedCommentCount = 0;
        cachedAdditionalData = null;
    }

    private async Task PerformReanalysis()
    {
        if (!canReanalyze || cachedComments is null)
            return;

        currentStatus = FeedbackProcessStatus.AnalyzingComments;
        currentStatusMessage = "Reanalyzing feedback...";
        StateHasChanged();

        // Create a new service for reanalysis
        var service = ServiceProvider.CreateAutoDataSourceService(
            autoDataSourceForm?.GetUrls().ToArray() ?? Array.Empty<string>(),
            HandleStatusUpdate);

        // Apply temporary prompt
        if (!string.IsNullOrWhiteSpace(customPrompt))
        {
            service.SetTemporaryPrompt(customPrompt);
        }
        else
        {
            service.ClearTemporaryPrompt();
        }

        // Call AnalyzeComments directly with cached data
        var (result, additionalData) = await service.AnalyzeComments(cachedComments, cachedCommentCount, cachedAdditionalData);
        markdownResult = result;
        currentAdditionalData = additionalData;

        // Handle feedbackSources for Auto source type
        if (additionalData is List<FeedbackSourceData> sources)
        {
            feedbackSources = sources;
        }
    }

    private Task HandleUrlsChanged(List<string> urls)
    {
        // Invalidate cache when URLs change
        if (selectedSource.Equals("Auto", StringComparison.OrdinalIgnoreCase))
        {
            var normalizedUrls = NormalizeUrls(urls);
            if (lastAnalyzedUrls != null && !normalizedUrls.SequenceEqual(lastAnalyzedUrls))
            {
                InvalidateCache();
            }
        }
        StateHasChanged();
        return Task.CompletedTask;
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        
        // Check if source changed and invalidate cache if needed
        if (lastSelectedSource != null && !string.Equals(lastSelectedSource, selectedSource, StringComparison.OrdinalIgnoreCase))
        {
            if (!selectedSource.Equals("Auto", StringComparison.OrdinalIgnoreCase))
            {
                InvalidateCache();
            }
        }
        lastSelectedSource = selectedSource;
    }

    bool isAuthenticating = false;
    private async Task HandleAuthenticatedWithDetails((bool success, bool justLoggedIn) details)
    {
        isAuthenticated = details.success;
        StateHasChanged();

        if (details.success && !isAuthenticating)
        {
            // Only handle post-login registration if the user just logged in
            // This avoids unnecessary backend calls when user was already authenticated
            if (details.justLoggedIn)
            {
                try
                {
                    isAuthenticating = true;
                    await AuthService.HandlePostLoginRegistrationAsync();
                }
                catch (Exception ex)
                {
                    // Log but don't fail the authentication flow if registration has issues
                    Console.WriteLine($"Post-login registration warning: {ex.Message}");
                }
                finally
                {
                    isAuthenticating = false;
                }
            }

            await HandleQueryNav();
            //await CheckForNewFeatures();
        }
    }

   
    private async Task CheckForNewFeatures()
    {

        try
        {
            // Check if user has history (indicating they've used the app before)
            var hasHistory = (await HistoryService.GetHistoryCountAsync()) > 0;
            
            // Only show new features dialog if user has history and hasn't seen latest features
            if (hasHistory && await UserSettings.ShouldShowFeatureAnnouncementAsync())
            {
                // Add a small delay to let the page fully render
                await Task.Delay(1000);
                showNewFeaturesDialog = true;
                StateHasChanged();
            }
            else 
            {
                // if they are a new user or have seen the announcement, mark it as shown
                await UserSettings.MarkFeatureAnnouncementShownAsync();
            }
        }
        catch (Exception)
        {
            // If anything fails, silently continue without showing the dialog
        }
    }

    private void CloseNewFeaturesDialog()
    {
        showNewFeaturesDialog = false;
        StateHasChanged();
    }

    private async Task MarkNewFeaturesAsSeen()
    {
        await UserSettings.MarkFeatureAnnouncementShownAsync();
        CloseNewFeaturesDialog();
    }

    private void CloseUsageLimitDialog()
    {
        showUsageLimitDialog = false;
        usageLimitError = null;
        StateHasChanged();
    }

    private void HandleStatusUpdate(FeedbackProcessStatus status, string message)
    {
        currentStatus = status;
        currentStatusMessage = message;
        StateHasChanged();
    }

    private string? GetUserInputForSource()
    {
        return selectedSource switch
        {
            "Manual" => manualInputForm?.ContentInput,
            "Auto" => autoDataSourceForm?.GetUrls() is { } urls && urls.Any() ? string.Join(", ", urls) : null,
            _ => null
        };
    }

    private object? GetAdditionalDataForAnalysis()
    {
        // For Auto source type, extract additional data from feedbackSources
        if (selectedSource == "Auto" && feedbackSources != null)
        {
            // Combine all additional data from all sources
            var allAdditionalData = feedbackSources
                .Where(source => source.AdditionalData != null)
                .Select(source => source.AdditionalData)
                .ToList();

            // If there's only one type of data, return it directly
            if (allAdditionalData.Count == 1)
            {
                return allAdditionalData[0];
            }
            
            // If there are multiple types, return them as a list
            if (allAdditionalData.Count > 1)
            {
                return allAdditionalData;
            }
        }

        // For other source types, return the raw additional data
        return currentAdditionalData;
    }

    private string selectedSourceFinal => selectedSource.Equals("Auto", StringComparison.OrdinalIgnoreCase)
        ? GetSourcesFromUrls()
        : selectedSource;

    private string GetSourcesFromUrls()
    {
        if (autoDataSourceForm?.GetUrls() is not { } urls || !urls.Any())
            return "Auto";
            
        var sources = new List<string>();
        
        foreach (var url in urls)
        {
            if (string.IsNullOrWhiteSpace(url))
                continue;
                
            if (UrlParsing.IsYouTubeUrl(url))
                sources.Add("YouTube");
            else if (url.Contains("reddit.com"))
                sources.Add("Reddit");
            else if (url.Contains("news.ycombinator.com") || url.Contains("hackernews"))
                sources.Add("HackerNews");
            else if (url.Contains("github.com"))
                sources.Add("GitHub");
            else if (url.Contains("devblogs.microsoft.com"))
                sources.Add("DevBlogs");
            else if (url.Contains("bsky.app"))
                sources.Add("BlueSky");
            else
                sources.Add("Web");
        }
        
        // Return unique sources as comma-separated list, or "Auto" if no sources identified
        return sources.Distinct().Any() ? string.Join(", ", sources.Distinct()) : "Auto";
    }


    private async Task SubmitFeedbackRequest()
    {
        try
        {
            // Reset all previous data
            error = "";
            markdownResult = "";
            feedbackSources = null;
            currentAdditionalData = null;
            isLoading = true;
            currentStatus = FeedbackProcessStatus.GatheringComments;
            currentStatusMessage = "Starting analysis...";

            // For Auto source, check Twitter access before submitting
            if (selectedSource == "Auto")
            {
                var urls = autoDataSourceForm?.GetUrls() ?? new List<string>();
                var (hasAccess, accessError) = await TwitterAccessService.CheckTwitterAccessAsync(urls);
                
                if (!hasAccess && !string.IsNullOrEmpty(accessError))
                {
                    error = accessError;
                    return;
                }
                
                // Check if we can reanalyze with cached data
                if (canReanalyze)
                {
                    await PerformReanalysis();
                    return;
                }
            }

            IFeedbackService service = selectedSource switch
            {
                "Auto" or "auto" => ServiceProvider.CreateAutoDataSourceService(
                    autoDataSourceForm?.GetUrls().ToArray() ?? Array.Empty<string>(),
                    HandleStatusUpdate),
                "Manual" or "manual" => ServiceProvider.CreateManualService(
                    manualInputForm?.GetContent() ?? string.Empty,
                    manualInputForm?.GetSystemPrompt(),
                    HandleStatusUpdate),
                _ => throw new InvalidOperationException("Please select a feedback source")
            };

            // Apply temporary prompt via new API so precedence is clear
            if (selectedSource.Equals("Auto", StringComparison.OrdinalIgnoreCase))
            {
                if (!string.IsNullOrWhiteSpace(customPrompt))
                {
                    service.SetTemporaryPrompt(customPrompt);
                }
                else
                {
                    service.ClearTemporaryPrompt();
                }
            }

            var (result, additionalData) = await service.GetFeedback();
            markdownResult = result;
            currentAdditionalData = additionalData;

            // Handle feedbackSources for Auto source type
            if (selectedSource == "Auto" && additionalData is List<FeedbackSourceData> sources)
            {
                feedbackSources = sources;
                
                // Capture cache data for potential reanalysis if this is an ICachableFeedbackService
                if (service is ICachableFeedbackService cachableService && cachableService.LastCommentsSnapshot.HasValue)
                {
                    var snapshot = cachableService.LastCommentsSnapshot.Value;
                    var urls = autoDataSourceForm?.GetUrls() ?? new List<string>();
                    lastAnalyzedUrls = NormalizeUrls(urls);
                    cachedComments = snapshot.comments;
                    cachedCommentCount = snapshot.commentCount;
                    cachedAdditionalData = snapshot.additionalData;
                }
            }
        }
        catch (UsageLimitExceededException ex)
        {
            usageLimitError = ex.LimitError;
            showUsageLimitDialog = true;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            // Check if this is a usage limit error from error message
            if (UsageLimitErrorHelper.TryParseUsageLimitError(ex.Message, out var limitError))
            {
                usageLimitError = limitError;
                showUsageLimitDialog = true;
            }
            else
            {
                error = $"An error occurred: {ex.Message}";
            }
            StateHasChanged();
        }
        finally
        {
            await Task.Delay(500); // Give time for UI to update before finalizing
            isLoading = false;
            currentStatus = FeedbackProcessStatus.Completed;
            currentStatusMessage = "";
            StateHasChanged();
        }
    }

    protected override async Task OnInitializedAsync()
    {
        // Subscribe to registration error events
        RegistrationErrorService.RegistrationErrorOccurred += OnRegistrationErrorOccurred;
        
        var uri = new Uri(NavigationManager.Uri);
        var query = System.Web.HttpUtility.ParseQueryString(uri.Query);

        // Check if this is an OAuth redirect (user just completed login)
        var isOAuthRedirect = !string.IsNullOrEmpty(query["code"]) || 
                             !string.IsNullOrEmpty(query["state"]) ||
                             uri.AbsolutePath.Contains("/.auth/login/");

        // Store auth status for later processing in OnAfterRenderAsync
        var authStatus = query["auth"];
        if (authStatus == "failed" || authStatus == "error")
        {
            // Store the auth error status to handle in OnAfterRenderAsync
            await Task.CompletedTask; // Placeholder - will handle in OnAfterRenderAsync
        }

        initialSource = query["source"]?.ToLower();
        initialId = query["id"];
        var url = query["url"];
        
        // If URL is provided, switch to Auto mode and use the URL
        if (!string.IsNullOrEmpty(url))
        {
            initialSource = "auto";
            initialId = url;
        }

        // If this is an OAuth redirect, check authentication and handle post-login registration
        if (isOAuthRedirect)
        {
            try
            {
                // Give time for OAuth tokens to settle
                await Task.Delay(500);
                
                var isAuthenticated = await AuthService.IsAuthenticatedAsync();
                if (isAuthenticated)
                {
                    // This is a fresh OAuth login, handle post-login registration
                    await HandleAuthenticatedWithDetails((true, true));
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"OAuth redirect handling error: {ex.Message}");
            }
        }

        await base.OnInitializedAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Handle authentication error logging after render
            var uri = new Uri(NavigationManager.Uri);
            var query = System.Web.HttpUtility.ParseQueryString(uri.Query);
            var authStatus = query["auth"];
            
            if (authStatus == "failed")
            {
                // Show authentication failed message
                await JSRuntime.InvokeVoidAsync("console.log", "Authentication failed");
            }
            else if (authStatus == "error")
            {
                // Show authentication error message
                await JSRuntime.InvokeVoidAsync("console.log", "Authentication error occurred");
            }
        }
    }    
    
    private async Task HandleQueryNav()
    {
        if (string.IsNullOrEmpty(initialSource) || string.IsNullOrEmpty(initialId))
            return;

        selectedSource = initialSource.ToLower() switch
        {
            "auto" or "hackernews" or "reddit" or "youtube" => "Auto",
            _ => selectedSource
        };
        StateHasChanged();        
        if (selectedSource == "Auto")
        {
            // Wait for autoDataSourceForm to be initialized, up to 10 attempts
            var attempts = 0;
            while (autoDataSourceForm is null && attempts < 10)
            {
                await Task.Delay(250);
                attempts++;
            }

            if (autoDataSourceForm is not null)
            {
                await autoDataSourceForm.HandleUrlChange(0, initialId);
                autoDataSourceForm.RefreshUI();
                StateHasChanged();
            }
        }
    }

    private void OnRegistrationErrorOccurred(object? sender, string errorMessage)
    {
        InvokeAsync(() =>
        {
            registrationErrorMessage = errorMessage;
            showRegistrationError = true;
            isAuthenticated = false;
            StateHasChanged();
        });
    }

    private async Task CloseRegistrationErrorDialog()
    {
        showRegistrationError = false;
        registrationErrorMessage = null;
        StateHasChanged();
        
        // Refresh the page to restart the authentication flow
        await Task.Delay(100); // Small delay to allow UI to update
        NavigationManager.NavigateTo("/", forceLoad: true);
    }

    private List<SharedDump.Models.CommentThread> GetUnifiedThreadsFromSources(List<FeedbackSourceData> sources)
    {
        var allThreads = new List<SharedDump.Models.CommentThread>();

        foreach (var source in sources)
        {
            if (source.AdditionalData != null)
            {
                List<SharedDump.Models.CommentThread> convertedThreads;
                
                // Handle HackerNewsAnalysis specifically since it's in the web app project
                if (source.AdditionalData is List<HackerNewsAnalysis> analyses)
                {
                    convertedThreads = HackerNewsCommentConverter.ConvertHackerNewsAnalysis(analyses);
                }
                else
                {
                    convertedThreads = CommentDataConverter.ConvertAdditionalData(source.AdditionalData);
                }
                
                allThreads.AddRange(convertedThreads);
            }
        }

        return allThreads;
    }

    public void Dispose()
    {
        // Unsubscribe from registration error events
        RegistrationErrorService.RegistrationErrorOccurred -= OnRegistrationErrorOccurred;
    }
}

@code {
    // Extension helper pattern inside the same file (scoped) to avoid broad changes
}
